/**
 * ObfuscatedOrderbook.compact
 * SilentLedger - Midnight Mini DApp Hackathon
 * 
 * This smart contract implements a privacy-preserving orderbook
 * that requires asset ownership verification before sell orders
 * can be placed, preventing short selling.
 */

pragma language_version 0.15;

import CompactStandardLibrary;
import "./AssetVerification.compact";

// Order types
enum OrderType { Buy, Sell }

// Order status
enum OrderStatus { Open, Filled, Cancelled }

// Order structure with privacy considerations
struct Order {
  id: Bytes<32>;           // Unique order ID (public)
  trader: Address;         // Address of the trader (private)
  orderType: OrderType;    // Buy or sell (public)
  assetId: Bytes<32>;      // Asset identifier (public)
  price: Uint<256>;        // Price per unit (public)
  amount: Uint<256>;       // Order amount (public)
  filled: Uint<256>;       // Amount filled so far (public)
  status: OrderStatus;     // Order status (public)
  timestamp: Uint<64>;     // Order creation timestamp (public)
  verificationId: Bytes<32>; // Required for sell orders (public)
}

// Ledger state
ledger assetVerificationAddr: Address;
ledger orders: Map<Bytes<32>, Order>;
ledger assetBuyOrders: Map<Bytes<32>, List<Bytes<32>>>;
ledger assetSellOrders: Map<Bytes<32>, List<Bytes<32>>>;

/**
 * Initialize the orderbook with the asset verification contract address
 */
export circuit initialize(verificationContractAddress: Address): [] {
  assetVerificationAddr = verificationContractAddress;
}

/**
 * Place a new order
 * For sell orders, requires verification of asset ownership
 */
export circuit placeOrder(
  caller: Address,
  assetId: Bytes<32>,
  orderType: OrderType,
  price: Uint<256>,
  amount: Uint<256>,
  verificationId: Bytes<32>,
  currentTime: Uint<64>
): Bytes<32> {
  assert(price > 0, "Price must be positive");
  assert(amount > 0, "Amount must be positive");
  
  // For sell orders, verify ownership
  if (orderType == OrderType.Sell) {
    // Import the AssetVerification contract to call its functions
    import { checkVerification } from "./AssetVerification.compact";
    
    // Check if verification is valid
    let result = checkVerification(caller, assetId, verificationId);
    assert(result[0], "Asset ownership verification failed or expired");
  }
  
  // Generate unique order ID
  let orderId = hash([caller, assetId, price, amount, currentTime]);
  
  // Create the order
  let order = Order {
    id: orderId,
    trader: caller,
    orderType: orderType,
    assetId: assetId,
    price: price,
    amount: amount,
    filled: 0,
    status: OrderStatus.Open,
    timestamp: currentTime,
    verificationId: orderType == OrderType.Sell ? verificationId : Bytes<32>::new()
  };
  
  // Store the order
  orders.set(orderId, order);
  
  // Add to appropriate list
  if (orderType == OrderType.Buy) {
    // Create list if it doesn't exist
    if (!assetBuyOrders.has(assetId)) {
      assetBuyOrders.set(assetId, List<Bytes<32>>::new());
    }
    
    let buyOrders = assetBuyOrders.get(assetId);
    buyOrders.append(orderId);
    assetBuyOrders.set(assetId, buyOrders);
  } else {
    // Create list if it doesn't exist
    if (!assetSellOrders.has(assetId)) {
      assetSellOrders.set(assetId, List<Bytes<32>>::new());
    }
    
    let sellOrders = assetSellOrders.get(assetId);
    sellOrders.append(orderId);
    assetSellOrders.set(assetId, sellOrders);
  }
  
  // Try to match the order immediately
  matchOrder(orderId);
  
  // Note: Events are handled by the Compact runtime automatically
  
  return orderId;
}

/**
 * Cancel an order
 * Only the order owner can cancel
 */
export circuit cancelOrder(
  caller: Address,
  orderId: Bytes<32>
): [] {
  // Get the order
  let order = orders.get(orderId);
  assert(order.status == OrderStatus.Open, "Order is not open");
  
  // Verify ownership
  assert(order.trader == caller, "Not order trader");
  
  // Update order status
  order.status = OrderStatus.Cancelled;
  orders.set(orderId, order);
  
  // Remove from asset order lists
  removeOrderFromAssetList(order.assetId, orderId, order.orderType);
  
  // Note: Events are handled by the Compact runtime automatically
}

/**
 * Match orders automatically
 * This is a simplified implementation for the hackathon
 */
circuit matchOrder(orderId: Bytes<32>): [] {
  let order = orders.get(orderId);
  
  // Skip if order is not open
  if (order.status != OrderStatus.Open) {
    return;
  }
  
  // Get the appropriate order list to match against
  let matchingOrderIds: List<Bytes<32>>;
  if (order.orderType == OrderType.Buy) {
    // If no sell orders for this asset, return
    if (!assetSellOrders.has(order.assetId)) {
      return;
    }
    matchingOrderIds = assetSellOrders.get(order.assetId);
  } else {
    // If no buy orders for this asset, return
    if (!assetBuyOrders.has(order.assetId)) {
      return;
    }
    matchingOrderIds = assetBuyOrders.get(order.assetId);
  }
  
  // Iterate through potential matches
  let i = 0;
  while (i < matchingOrderIds.length() && order.filled < order.amount) {
    let matchOrderId = matchingOrderIds.get(i);
    
    // Skip if order doesn't exist
    if (!orders.has(matchOrderId)) {
      i++;
      continue;
    }
    
    let matchOrder = orders.get(matchOrderId);
    
    // Skip if not open
    if (matchOrder.status != OrderStatus.Open) {
      i++;
      continue;
    }
    
    // Check price matching
    let priceMatches = false;
    if (order.orderType == OrderType.Buy) {
      priceMatches = order.price >= matchOrder.price;
    } else {
      priceMatches = order.price <= matchOrder.price;
    }
    
    if (priceMatches) {
      // Calculate fill amount
      let fillAmount = min(order.amount - order.filled, matchOrder.amount - matchOrder.filled);
      
      if (fillAmount > 0) {
        // Update order fill amounts
        order.filled += fillAmount;
        matchOrder.filled += fillAmount;
        
        // Update statuses if fully filled
        if (order.filled == order.amount) {
          order.status = OrderStatus.Filled;
        }
        
        if (matchOrder.filled == matchOrder.amount) {
          matchOrder.status = OrderStatus.Filled;
        }
        
        // Save updated orders
        orders.set(orderId, order);
        orders.set(matchOrderId, matchOrder);
        
        // Emit events
        // Note: Order fill events are handled by the Compact runtime automatically
      }
    }
    
    i++;
  }
}

/**
 * Get order details (public information only)
 */
export circuit getOrder(orderId: Bytes<32>): [Bytes<32>, OrderType, Bytes<32>, Uint<256>, Uint<256>, Uint<256>, OrderStatus, Uint<64>] {
  assert(orders.has(orderId), "Order does not exist");
  let order = orders.get(orderId);
  
  return [
    order.id,
    order.orderType,
    order.assetId,
    order.price,
    order.amount,
    order.filled,
    order.status,
    order.timestamp
  ];
}

/**
 * Get order book for an asset
 * Returns arrays of order IDs
 */
export circuit getOrderBook(assetId: Bytes<32>): [List<Bytes<32>>, List<Bytes<32>>] {
  let buyOrders = List<Bytes<32>>::new();
  let sellOrders = List<Bytes<32>>::new();
  
  // Get buy orders if they exist
  if (assetBuyOrders.has(assetId)) {
    let rawBuyOrders = assetBuyOrders.get(assetId);
    
    // Filter to only include open orders
    for (let i = 0; i < rawBuyOrders.length(); i++) {
      let buyOrderId = rawBuyOrders.get(i);
      if (orders.has(buyOrderId)) {
        let order = orders.get(buyOrderId);
        if (order.status == OrderStatus.Open) {
          buyOrders.append(buyOrderId);
        }
      }
    }
  }
  
  // Get sell orders if they exist
  if (assetSellOrders.has(assetId)) {
    let rawSellOrders = assetSellOrders.get(assetId);
    
    // Filter to only include open orders
    for (let i = 0; i < rawSellOrders.length(); i++) {
      let sellOrderId = rawSellOrders.get(i);
      if (orders.has(sellOrderId)) {
        let order = orders.get(sellOrderId);
        if (order.status == OrderStatus.Open) {
          sellOrders.append(sellOrderId);
        }
      }
    }
  }
  
  return [buyOrders, sellOrders];
}

/**
 * Helper function to get minimum of two values
 */
circuit min(a: Uint<256>, b: Uint<256>): Uint<256> {
  return a < b ? a : b;
}
