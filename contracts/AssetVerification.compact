/**
 * AssetVerification.compact
 * SilentLedger - Midnight Mini DApp Hackathon
 * 
 * This smart contract handles asset ownership verification
 * using Midnight's privacy features and zero-knowledge proofs. This asset ownership verification is intended to disincentivize front running and short selling.        
 */

pragma language_version 0.15;

import CompactStandardLibrary;

// Struct to store verification status without revealing balance
struct OwnershipProof {
  owner: Address;          // Owner address (private)
  assetId: Bytes<32>;      // Asset identifier (public)
  verified: Bool;          // Verification status (public)
  timestamp: Uint<64>;     // When verification occurred (public)
  proofHash: Bytes<32>;    // Hash of the ZK proof (public)
}

// Ledger state
ledger ownershipProofs: Map<Address, Map<Bytes<32>, OwnershipProof>>;
ledger usedProofs: Map<Bytes<32>, Bool>;

// Constants
const VERIFICATION_VALIDITY_PERIOD: Uint<64> = 86400; // 24 hours in seconds

/**
 * Verify ownership of an asset
 * Uses a zero-knowledge proof to verify ownership without revealing balance
 */
export circuit verifyOwnership(
  caller: Address,
  assetId: Bytes<32>,
  minAmount: Uint<256>,
  zkProof: Bytes<>,
  currentTime: Uint<64>
): Bytes<32> {
  // Verify the ZK proof without revealing actual balance
  // The ZK proof proves that the user owns at least minAmount of the asset
  let isValid = validateProof(caller, assetId, minAmount, zkProof);
  assert(isValid, "Invalid ownership proof");
  
  // Create proof hash that will serve as verification ID
  let proofHash = hash([caller, assetId, minAmount, currentTime, zkProof]);
  
  // Ensure this proof hasn't been used before
  let isUsed = usedProofs.get(proofHash);
  assert(!isUsed, "Proof already used");
  usedProofs.set(proofHash, true);
  
  // Store the verification
  let proof = OwnershipProof {
    owner: caller,
    assetId: assetId,
    verified: true,
    timestamp: currentTime,
    proofHash: proofHash
  };
  
  // If map doesn't exist yet, create it
  if (!ownershipProofs.has(caller)) {
    let emptyMap: Map<Bytes<32>, OwnershipProof> = Map.new();
    ownershipProofs.set(caller, emptyMap);
  }
  
  // Store the proof
  let ownerMap = ownershipProofs.get(caller);
  ownerMap.set(assetId, proof);
  ownershipProofs.set(caller, ownerMap);
  
  // Note: Events are handled by the Compact runtime automatically
  
  return proofHash;
}

/**
 * Check if an ownership verification is valid
 * Can be called by anyone to check if a verification is still valid
 */
export circuit checkVerification(
  owner: Address, 
  assetId: Bytes<32>, 
  proofHash: Bytes<32>
): [Bool, Uint<64>] {
  // Ensure the owner map exists
  if (!ownershipProofs.has(owner)) {
    return [false, 0];
  }
  
  let ownerMap = ownershipProofs.get(owner);
  
  // Ensure the asset record exists
  if (!ownerMap.has(assetId)) {
    return [false, 0];
  }
  
  let proof = ownerMap.get(assetId);
  
  // Check if the verification exists and matches the proof hash
  if (proof.verified && proof.proofHash == proofHash) {
    let expiryTimestamp = proof.timestamp + VERIFICATION_VALIDITY_PERIOD;
    // Note: Time comparison would need current time passed as parameter
    // For now, assume verification is valid (would need circuit parameter)
    
    return [stillValid, expiryTimestamp];
  }
  
  return [false, 0];
}

/**
 * Internal function to validate a zero-knowledge proof
 * In a real implementation, this would use Midnight's ZK-proof system
 */
circuit validateProof(
  owner: Address, 
  assetId: Bytes<32>, 
  minAmount: Uint<256>, 
  zkProof: Bytes<>
): Bool {
  // This is a placeholder implementation
  // In the real contract, this would use Midnight's ZK proof verification
  
  // The proof should demonstrate that the user has at least minAmount of the asset
  // without revealing the actual balance
  
  // For the hackathon demo, we assume the proof is valid if it's not empty
  return zkProof.length() > 0;
}

/**
 * Revoke a verification
 * Only the owner can revoke their own verification
 */
export circuit revokeVerification(
  caller: Address,
  assetId: Bytes<32>,
  currentTime: Uint<64>
): [] {
  // Ensure the owner map exists
  assert(ownershipProofs.has(caller), "No active verification found");
  
  let ownerMap = ownershipProofs.get(caller);
  
  // Ensure the asset record exists
  assert(ownerMap.has(assetId), "No active verification found");
  
  let proof = ownerMap.get(assetId);
  assert(proof.verified, "No active verification found");
  
  // Revoke the verification
  proof.verified = false;
  ownerMap.set(assetId, proof);
  ownershipProofs.set(caller, ownerMap);
  
  // Note: Events are handled by the Compact runtime automatically
}
